# 《高性能MySQL》读书笔记

## 第1章 MySQL架构与历史

MySQL最重要、最与众不同的特性是它的存储引擎架构，这种架构将查询处理与数据的存储/提取相分离，使得可以在使用时根据不同的需求来选择数据存储的方式。

### MySQL逻辑架构
           客户端
 ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ 
+--------------------------+
-        连接/线程处理       -   // 连接处理、授权认证、安全
+--------------------------+
     ↓                ↓
+---------+      +---------+
- 查询缓存 -   ←  -  解析器  -   // 查询解析、优化、缓存、内置函数、存储过程、触发器、视图
+---------+      +---------+
                      ↓
+--------------------------+
-          优化器           -
+--------------------------+

+--------------------------+
-         存储引擎          -   // 数据的存储和提取
+--------------------------+

服务器通过API与存储引擎进行通信，这些API屏蔽了不同存储引擎之间的差异。存储引擎API包含几十个底层函数，不同存储引擎不会去解析SQL，而只是简单地响应上层服务器的请求。

每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个线程中执行，该线程只能轮流在某个CPU核心中运行。MySQL基于线程池来管理线程（创建、缓存、销毁）。

当客户端连接到MySQL服务器时，服务器会基于用户名、主机信息、密码等进行认证。一旦客户端连接成功，服务器会继续验证该客户端是否具有执行某个特定查询的权限。

MySQL会解析查询并创建查询解析树，然后对其进行各种优化，如重写查询、决定表的读取顺序、选择合适的索引等。用户可以通过使用关键字提示优化器，从而影响它的决策过程。

优化器不关心表使用的是什么存储引擎，但`存储引擎对于优化查询是有影响的`：优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等。

`对于SELECT语句`，在`解析查询之前`，服务器会先检查查询缓存，如果找到对应的查询，就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。

### 并发控制
加锁本身也需要消耗资源，锁策略就是在锁的开销和安全性之间寻求平衡。每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。

`表锁`：会锁定整张表，在对表进行写操作之前，需要先获得写锁，获得写锁后将会阻塞其他用户对该表的读写操作。只有没有写锁时，其他用户才能获取读锁，读锁之间是不相互阻塞的。写锁比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面。

虽然不同的存储引擎都有自己的锁实现，MySQL自身仍然会在服务器层使用表锁并忽略存储引擎的锁机制，例如当执行ALTER TABLE时，`服务器`会使用表锁。

`行级锁`：行级锁只在存储引擎层实现，MySQL服务器层没有实现。

### 事务
ACID：atomicity(原子性)、consistency(一致性)、isolation(隔离性)、durability(持久性)。

隔离级别：SQL标准定义了4种隔离级别，每一种级别都规定了在一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。
1. `READ UNCOMMITED` 
事务中的修改，即使没有提交，对其他事务也是可见的。（因此会产生脏读）
2. `READ COMMITTED`
一个事务只能看见已经提交的事务所做的修改。
3. `REPEATABLE READ`
这是MySQL默认的事务隔离级别，保证在同一个事务中多次读取同样记录的结果是一样的。理论上该级别无法避免幻读的问题，InnoDB通过多版本并发控制解决了幻读的问题。
4. `SERIALIZABLE`
强制事务串行执行，会在读取的每一行数据上都加锁，可能导致大量的超时和锁争用问题。

可以在配置文件中设置整个数据库的隔离级别，也可以只改变当前会话的隔离级别：
SET SESSION TRANSACTION LEVEL READ COMMITTED;

死锁：当多个事务试图以不同的顺序锁定资源时，就可能产生死锁。（两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环）对于事务型的系统，死锁发生后，只有部分或者完全回滚其中一个事务，才能打破死锁。InnoDB目前处理死锁的方式是：在检测到死锁循环依赖后，将持有最少行级排它锁的事务进行回滚。

事务日志：事务日志可以帮助提高事务的效率，存储引擎在修改表的数据时只需要修改表数据的内存拷贝，同时把该修改行为持久化到硬盘中的事务日志中，相比于将修改的数据本身持久化到磁盘，事务日志采用的是追加的方式，因此是在磁盘上的一小块区域内顺序地写入，而不是随机的I/O操作。事务日志持久化后，内存中被修改的数据在后台可以慢慢刷回磁盘，如果在数据没有写回磁盘时系统崩溃了，存储引擎在重启时能够自动恢复这部分数据。目前大多数存储引擎都是这样实现的。

MySQL默认采用自动提交模式，如果不是显式地开始一个事务，则每个查询都会被当做一个事务执行提交操作。可以在当前连接中设置`AUTOCOMMIT`变量来禁用自动提交模式(禁用后，需要显式地执行COMMIT提交或者ROLLBACK回滚)。对于非事务型的表，修改AUTOCOMMIT不会有任何影响，这类表相当于一直处于AUTOCOMMIT启用的状态。
此外，有一些命令，例如ALTER TABLE，在执行之前会强制执行COMMIT提交当前的活动事务。

如果在事务中混合使用了事务型和非事务型的表，当事务需要回滚时，非事务型表上的变更将无法撤销，这将导致数据库处于不一致的状态。在非事务型表上执行事务相关操作时，MySQL通常并不会报错，只会给出一些警告。

显式锁定：MySQL也支持LOCK TABLES和UNLOCK TABLES语句，这是在服务器层实现的，但它们不能代替事务处理，如果应用到事务，还是应该选择事务型存储引擎。
（建议：除了在事务中禁用了AUTOCOMMIT时可以使用LOCK TABLE之外，其他任何时候都不要显式地执行LOCK TABLES，不管使用的是什么存储引擎，因为LOCK TABLE和事务之间相互影响时，问题会变得非常复杂）

InnoDB也支持通过特定的语句进行显式锁定，这些语句不属于SQL规范，如：
SELECT ... LOCK IN SHARE MODE
SELECT ... FOR UPDATE

### 多版本并发控制
可以认为MVCC是行级锁的一个变种，但是它在很多情况下都避免了加锁操作，因此开销更低（更高并发）。其实现原理是通过保存数据在某个时间点的快照来实现的，根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。
InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的，这两个列一个保存行的创建版本号，一个保存行的过期版本号，每开始一个新的事务，系统版本号就会自动递增。事务开始时刻的版本号会作为事务的版本号用来和查询到的每行记录的版本号进行比较。
MVCC只在REPEATABLE和READ COMMITED两个隔离级别下工作，其他两个隔离级别和MVCC不兼容。
（在不同隔离级别下，每种查询的具体行为，略）

### MySQL的存储引擎
MySQL将每个数据库保存为数据目录下的一个子目录，创建表时，MySQL会在数据库子目录下创建一个和表同名的.frm文件来保存表的定义。
可以使用SHOW TABLE STATUS命令或者查询INFOMATION_SCHMA中对应的表来显示某个表的相关信息。
InnoDB在95%的情况下都是最好的选择。
（InnoDB、MyISAM、其他内建及第三方引擎概述，略）

### MySQL时间线
（即版本变更历史，略）

### MySQL的开发模式
（开发过程和发布模型，略）


## MySQL基准测试
基准测试是针对系统设计的一种压力测试，通常的目标是为了`掌握系统的行为`。

### 基准测试的策略
两种主要策略：针对系统的整体测试，单独测试MySQL。

`测试指标`：
1.吞吐量：单位时间内的事务处理数；
2.响应时间（延迟）：完成测试任务所需的时间；（95%法则）
3.并发性：测试应用在不同并发下的性能；
4.可扩展性：线性扩展；

### 基准测试方法
（常见的测试设计错误，略）

### 基准测试工具
ab、http_load、JMeter
mysqlslap、MySQL Benchmark Suite、Super Smack...
(工具介绍，略)

### 基准测试案例
（略）



## 第3章 服务器性能剖析
性能：完成某件任务所需要的时间度量，性能即响应时间。
性能剖析（profiling）：测量服务器的时间花费在哪里。
性能剖析的步骤：测量任务所花费的时间，然后对结果进行统计和排序，将重要的任务排到前面。

### 对应用程序进行性能剖析
使应用的可测量，性能剖析的代码会导致服务器变慢，可以采用`随机采样`：
```
<?php
$profiling_enabled = rand(0,100) > 99;
...
```

（PHP程序的性能测试，推荐facebook的xhprof，详略）

### 剖析MySQL查询
在MySQL中可以通过设置long_query_time为0来捕获所有的查询，目前查询的相应时间单位已经精确到微秒级。

在MySQL中，慢查询日志是开销最低、精度最高的测量查询时间的工具。对CPU的开销很少，但是可能消耗大量的磁盘空间。

也可以通过tcpdump抓取TCP包，然后使用pt-query-digest --type=tcpdump选项来解析并分析查询。

（使用pt-query-digest解析慢查询日志，略）

剖析单条查询：
```
SET profiling = 1;
SELECT * ...
SHOW PROFILES;               # 所有查询的统计
SHOW PROFILE FOR QUERY 1;   # 单条查询的详情，给出查询执行的每个步骤及花费的时间
```
也可以不使用SHOW PROFILE命令，而是直接查询INFOMATION_SCHEMA中对应的表，这样可以自定义输出数据的格式（按特定字段排序等）。

可以使用SHOW STATUS命令返回查询计数器（但无法给出消耗了多少时间）。最有用的计数器是句柄计数器、临时文件、表计数器等。
```
FLUSH STATUS;
SELECT * FROM ...
SHOW STATUS WHERE Variable_name LIKE 'Handler%' OR Variable_name LIKE 'Created';
```
SHOW STATUS本身也会创建一个临时表，而且也会通过句柄操作访问此临时表，也会影响到SHOW STATUS结果中对应的数字。

`Performance Schema`：5.5中新增，目前还在快速开发中

### 诊断间歇性问题
（案例，略）

### 其他剖析工具
（略）


## 第4章 Schema与数据类型优化

### 选择优化的数据类型

选择数据类型的几个简单原则：
1.更小的通常更好；
2.简单就好：整型操作比字符型操作代价低；使用整型存储IP地址；
3.尽量避免NULL：可为NULL的列需要更多的存储空间，在索引优化时也更复杂（需要记录额外的字节）；（InnoDB使用单独的bit存储NULL值，这对于稀疏数据有很好的空间效率）

TIMESTAMP只使用DATATIME一半的存储空间，且会根据时区自动更新，但是它允许的范围要小很多（1970年开始）。

MySQL中的INTEGER、BOOL等只是基本类型的别名，如果用这些名字建表，SHOW CREATE TABLE仍然显示基本类型。

MySQL可以为整数类型指定宽度，例如INT(11),但这实际并不会限制值的合法范围，作用只是规定了MySQL的一些交互工具用来显示字符的个数，对于存储和计算来说，INT(1)和INT(20)是相同的（都是11位）。其他整型数同理。

TINYINT的存储空间为`8位`，存储值范围为-128~127，TINYINT UNSIGNED的存储范围是0~255；

VARCHAR需要使用1或2个额外字节记录字符串的长度：如果列的最大长度小于等于255，则只使用1个字节，否则使用2个字节，所以一个VARCHAR(10)的列需要11个字节的存储空间，VARCHAR(1000)的列则需要1002个字节。

比较适合使用VARCHAR类型的情况：
1.字符串的最大长度比平均长度大很多；
2.列的更新很少；（更新导致长度变化，会有额外的更新操作）
3.使用了像UTF-8这样的复杂字符集，每个字符使用不同的字节数进行存储；

InnoDB可以把过长的VARCHAR存储为BLOB；

MySQL把BLOB和TEXT值当做独立的对象处理，当其太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。

如果使用完全随机的字符串作为标识列，例如使用MD5值，会导致INSERT以及UPDATE语句变得很慢，原因可能有：
1.插入值会随机地写到索引的不同位置，使得INSERT语句更慢，会导致页分裂，磁盘随机访问，产生聚簇索引碎片；
2.SELECT会更慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方；
3.随机值导致缓存对所有类型的查询语句效果都很差；（局部性原理失效）

（其他类型，略）


### MySQL schema设计中的陷阱
1.太多的列：存储引擎API需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列，这个操作的代价非常高，而转换的代价依赖于列的数量。
2.太多的关联：对于MySQL来说，EAV（实体-属性-值）设计模式是一个糟糕的设计模式，MySQL限制了每个关联操作最多只能有61张表。经验表明，单个查询最好在12个表以内做关联。

### 范式和反范式
（范式、反范式各自的优缺点，略）
完全的范式化和完全的反范式化schema都是实验室里才有的东西，在实际应用中经常需要混用。

### 缓存表和汇总表
缓存表：存储那些可以比较简单地从schema其他表获取数据的表（存在逻辑上冗余的数据）；
汇总表：保存使用GROUP BY语句聚合数据的表；

MySQL原生不支持物化视图，但是可以通过插件实现。

使用随机方式实现计数器表：如下的网站点击统计计数器表存在并发问题：
```
CREATE TABLE hit_counter(
  cnt int unsigned not null
) ENGINE=InnoDB;
```
当网站发生点击时：
```
UPDATE hit_counter SET cnt = cnt + 1;
```
要获得更高的并发更新性能，可以将数据器保存在多行中，每次随机选择一行进行更新，修改计数器表如下：
```
CREATE TABLE hit_counter(
  slot tinyint unsigned not null primary key,
  cnt int unsigned not null
)ENGINE=InnoDB;
```
当发生更新操作时，选择一个随机的行进行更新：
```
UPDATE hit_counter SET cnt = cnt + 1 WHERE slot = RAND() * 100;
```
如下获取统计结果：
```
SELECT SUM(cnt) FROM hit_counter;
```

### 加快ALTER TABLE操作的速度
常规的方法是建另一张结构符合要求的表，并插入旧表的数据，然后切换主从，或者切换新旧表。
修改表的.frm文件是很快的，因此可以为想要创建的表结构创建一个新的.frm文件，然后用它替换掉已经存在的表的.frm文件。（详略）

### 在有索引的情况下快速导入表数据
常规的方法：
1.先删除索引：如ALTER TABLE t.data DISABLE KEYS;  # 对唯一索引无效
2.导入数据
3.再创建索引：如ALTER TABLE t.data ENABLE KEYS; 

hack方法是直接修改.MYD、.frm、.MYI等文件，详略。


## 第5章 创建高性能索引

### 索引基础
在MySQL中，索引是在存储引擎层而不是服务器层实现的，并没有统一的索引标准，不同的存储引擎索引工作的方式是不一样的。

### 索引类型
1.`B-Tree索引`
意味着所有的索引都是按顺序存储的，并且每一个叶子页到根的距离相同。
B-Tree索引可应用于如下类型的查询：
（1）全值匹配：和索引中的所有列进行匹配；
（2）匹配最左前缀：如当索引有多列时，只使用索引的第一列；
（3）匹配列前缀：只使用索引第一列的值的开头部分；
（4）匹配范围值：只使用索引的第一列；
（5）精确匹配某一列，并范围匹配另一列：只使用索引的第一列及第二列的开头部分；
（6）只访问索引的查询：查询只需要访问索引，而无须访问数据行，即`覆盖索引`；
（7）可用于ORDER BY查询；

B-Tree索引的限制：
（1）如果不是按照索引的最左列开始查找，则无法使用索引；
（2）不能跳过索引中的列；
（3）如果查询中有某个列的范围查询（包括LIKE等），则其右边所有列都无法使用索引优化查找；


2.`哈希索引`
基于哈希表实现，对于每一行数据存储引擎都会对所有的索引列计算一个哈希码，只有精确匹配索引所有列的查询才有效。
只有Memory引擎显式支持哈希索引。（详略）

InnoDB有一个特殊的功能：`自适应哈希索引`，当InnoDB注意到某些索引值被使用得非常频繁时，就会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比如快速的哈希查找。


3.空间数据索引（R-Tree）
MyISAM表支持空间索引，可以用作地理数据存储。


4.全文索引
查找的是文本中的关键词，而不是直接比较索引中的值。适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。

### 索引的优点





























