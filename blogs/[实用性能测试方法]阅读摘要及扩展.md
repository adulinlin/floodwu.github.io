# <a HREF="https://github.com/rickyqiu/TrainingMaterials/blob/master/%E5%AE%9E%E7%94%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95-%E5%AE%8C%E6%95%B4%E7%89%88_rickyqiu.pdf">实用性能测试方法</a>阅读摘要及扩展


## 1 关于性能测试的一些概念和测试计划

### 性能测试的目的
1.验证产品是否符合需求；
2.找到产品的性能瓶颈，并改进性能；
3.对技术解决方案进行评估；
4.竞品分析；
等等

### 性能测试的类型
1.加载测试；
2.压力测试：确定系统的崩溃点，或者性能上限；
3.稳定性测试：确定系统在长时间运行状态的性能情况；
4.可扩展性测试：当前系统架构的可承载规模，及扩展后的规模；
5.基准测试：定量的、可以和预先定义基准进行对比的测试；

### 基础概念
1.精确与模糊（Precise vs Vague）
性能测试与功能测试的一个很大的不同之处在于：性能测试需要获取精确的结果数据，因此性能测试时精确的测试。
困难在于：
（1）难以决定最终使用哪种精确的样本或者配置；（就像难以确定一辆车行驶100公里精确需要多少油一样）
（2）测试所用的环境与生产环境有差别；
（3）难以获取真实场景中的精确数据；
因此，性能测试的主要价值在于：
（1）避免因性能问题带来的质量风险；
（2）提供参考性意见，如与上个版本相比没有明显的性能下降、某个解决方案能够比另一个带来显著的性能提升、需要多少台服务器才可以满足需求等；
（3）我们的产品能否满足业界的性能标准，或者不输给竞品；

2.宏观与微观（Macro vs Micro）
有时候，当我们进行如下的操作时，系统整体的性能会有明显的变化，如：
（1）修改日志的级别，如改为debug级；
（2）修改进程数量；
（3）启用一个缓存；
（4）启用keepalive
（5）启用递归的DNS查询
等等
Although it's necessary to have an overview of the problem,the big picture often turns on one `critical detail`.

3.项目与任务（Project vs Task）
性能测试是团队性的工作；
性能测试是由许多阶段组成的、持续性的工作；

性能测试的工作流程
![image](https://github.com/woojean/woojean.github.io/blob/master/images/test_1.png)


## 2 性能测试工具
（硬件测试工具，略）

### 典型性能测试工具架构
![image](https://github.com/woojean/woojean.github.io/blob/master/images/test_2.png)

### 商业测试工具
LoadRunner
SilkPerformer
Rational Performance Tester

### 开源测试工具
Apache AB
JMeter

### Apache AB
./ab -c 10 -n 1000 http://127.0.0.1/index.php
-n 总请求个数
-c 并发数
-t 测试所进行的最大秒数，默认50000
-p 需要POST的数据的文件，文件格式如"p1=1&p2=2"，使用方法是-p 111.txt
-T POST数据所使用的Content-type头信息，如 -T "application/x-www-form-urlencoded"
-X proxy:port 代理设置
-k 打开HTTP KeepAlive功能

### JMeter
（单独研究）

### 测试工具的评估和选型
1.功能：是否支持产品所使用的网络协议、能否模拟我们需要的场景、报表的内容；
2.性能：工具自身的性能上限，能否支持到我们想要的量级；
3.是否被认可：业界的使用经验和结果、公司内部的认可情况；
4.License类型和费用；
5.可扩展性：能否支持后续产品型号、是否被公司其他项目使用；
6.技术支持：如何寻求帮助、有无相应的培训、工具的维护和升级


## 3 虚拟用户的创建

### 协议层次的行为
如用户打开一个包含很多链接的网页，其在TCP层面可能的请求方式是多样的：
1.[ 打开一个TCP连接 -> 获取URL内容 -> 关闭TCP连接 ]循环                         // 普通
2.打开一个TCP连接 -> [ 一个一个地获取URL内容 ]循环 -> 关闭TCP连接               // 复用
3.打开多个线程{ 打开一个TCP连接 -> 获取URL内容 -> 关闭TCP连接 }                 // 并行
4.打开多个线程{打开一个TCP连接 -> [ 一个一个地获取URL内容 ]循环 -> 关闭TCP连接} // 并行 + 复用

通过wireshark查看不同TCP请求的端口号（src port），如果不同的请求使用了相同的端口号，则说明打开了TCP`复用`。
在Chrome中查看Timeline，如果发现多个请求在时间上并行，则说明启用了多线程`并行`请求；

例："对于一个网站首页的访问，浏览器会先取回这个页面的html文件，然后解析内容，进而发起请求去取其他页面展示所需要的元素，比如图片，css，js等"，但这并非总是正确的，使用Chrome，从TCP抓包结果分析可以看到，在首页的response完全返回之前，已经开始发出内嵌资源的请求。

不光是HTTP，其他应用层协议，比如SMTP等也存在类似的问题。

总之，需要问这两个问题：
1.我们产品的客户端/agent等与server交互的时候是什么样的行为？有没有类似的并行度设置？
2.我们是否可以模拟出这样的行为？这样才能真实的反映性能。


### 产品层次的行为
把每一个产品功能层面的操作转变为具体的协议级别的请求和响应，如：
1.打开页面
2.登录
3.浏览数据
4.提交数据
5.搜索数据

例如，Google地图的放大功能实际对应一串HTTP请求。


### 用户层次的行为
1.用户的使用序列/路径
2.用户的使用习惯，比如同时开多个窗口
3.早/晚高峰、节假日
等等


### 获取用户行为特征
1.从真实场景取样
（1）日志分析
（2）用户调研
（3）监控系统
（4）报表数据

2.数学方法

3.合理的假设与参考
对于新的产品，没有历史数据可以参考，只能做一些看起来合理的假设，比如：
（1）一个用户在工作时同时打开的文件个数
（2）一般邮件发给多少收件人
（3）一个用户有多少个好友
（4）一个页面有多少元素
（5）一般有多少用户访问
等等


### 描述单个用户的行为
1.使用参数列表，比如JMeter的User Params
2.录制+回放，可以使用JMeter的代理服务器实现录制



## 4 用户场景的建模
“Visitors to your Web site think, read, and type at different speeds, and it's your job to figure out how to model and script those varying speeds as part of your testing process.”

性能测试也是一种模拟：
1.用什么样的sample？
2.一个用户进来做哪些操作？
3.覆盖哪几类用户？
4.每一类用户有多少个？



## 5 测试流量的产生
流量放大的方法：多线程/多进程

### 动态压力曲线
1.测试本身的需要
（1）产品的热身，压力逐步上升：服务器进程/线程增长、有些产品有防大量突发请求的策略
（2）流量正常终止，收尾处请求也得到完整的处理
（3）测试工具也需要热身：进程/线程创建、加载测试样本文件

2.模拟请求的波动
（1）不同时段的流量波动，更接近真实的场景
（2）模拟大量突发的请求：看产品处理这种情况下的性能（同时也要考察稳定性）

3.阶梯指标测试
（1）获取不同压力下的性能表现
（2）寻找稳定的性能峰值：逐步接近，每一个台阶都要稳定一段时间

### 虚拟网络地址
常见的需要模拟IP的原因：
1.产品功能本身要求IP的多样性：不同客户端的请求不能用同一个IP
2.被测产品需要对IP做处理或者限制：比如限制一个IP的连接数
3.被测产品需要存储IP相关的信息：比如DB字段，log，需要散列开来

硬件解决方案：Avalanche subnet
软件工具方案：SilkPerformer

### 模拟真实网络环境
常见的需要模拟真实网络环境的原因：
1.想要获取接近真实网络情况下的性能：不同的网络带宽、不同的网络延迟、部分丢包的情况
2.观察网络抖动对性能的影响：涉及错误处理的机制和效果

使用：Avalanche Realism Simulation 或者 Network Delay simulator 


## 6 测试数据的收集

### 数据的类型和常见指标
1.产品的性能指标
直接关注的性能指标，`和产品的类型直接相关`，通常由流量发生工具直接给出。例如：
（1）支持的最大并发用户数
（2）每秒的事务(文件/邮件/请求)处理数
（3）请求响应时间
（4）响应延时
（5）支持的最大带宽
等等

2.系统资源使用的数据
即系统在达到这样的性能时资源使用情况如何，原因有：
（1）到极限了吗？余量有多少？
（2）确定硬件的需求
（3）瓶颈在哪里？
没有资源使用情况的产品性能指标数据是不严谨 ，也不具有完整参考价值的
常见系统资源使用指标：
（1）CPU使用率
（2）内存使用情况
（3）网络带宽使用情况
（4）磁盘IO情况
（5）其他硬件的资源使用情况

3.产品的其他指标数据
需要更多的数据来监控性能测试中产品的运行情况，也有助于发现问题和瓶颈。
（1）主要进程的内存使用和增长情况
（2）主程序的进程/线程数，及动态增长情况
（3）队列的使用情况
（4）Cache/buffer的使用情况
（5）打开的文件句柄数
（6）目录下文件数，log size


### Linux下常见资源使用指标
#### 1.CPU usage
top
![image](https://github.com/woojean/woojean.github.io/blob/master/images/test_3.png)
us: user time;       CPU在用户空间执行的时间
sy: system time;     CPU在内核控件执行的时间
ni: nice time;       CPU在低优先级进程上执行的时间
id: idle time;       CPU空闲的时间
wa: io wait time     CPU在IO等待执行的实际
hi: hard irq time;   CPU处理硬件中断所花的时间
si: software irq time  CPU处理软件中断所花的时间
st: steal time       虚拟机偷取时间，在其中一台虚拟机上用top查看发现st不为0，就说明本来有这么多个cpu时间是安排给我这个虚拟机的，但是由于某种虚拟技术，把这个cpu时间分配给了其他的虚拟机了。这就叫做偷取。

#### 2.CPU usage %的计算
bash-3.00# cat /proc/stat | grep "cpu"
cpu 1129215 0  1311793 37097490  70380 4425  11038
以上数据分别对应us, ni, sy, id, wi, hi, si

计算方法 ：
（1）采样两个足够短的时间间隔的CPU快照，分别记作t1, t2，其中t1、t2的结构均为：
(user、nice、system、idle、iowait、irq、softirq)的7元组;
（2）计算总的Cpu时间片totalCpuTime
   a) 把第一次的所有cpu使用情况求和，得到st1;
   b) 把第二次的所有cpu使用情况求和，得到s2;
   c) s2 - s1得到这个时间间隔内的所有时间片
（3）计算空闲时间idle
   idle对应第四列的数据
   i2 - i1 = 第二次的第四列 - 第一次的第四列
（4）计算总cpu使用率
   pcpu =(1 - (i2-i1)/(s2–s1)) * 100%
其他CPU使用率计算类似。
* 不同Linux系统/proc/stat的列数可能有差异

#### 3.CPU使用相关的细节指标
（1）用户进程使用CPU的比率：该程序占用的CPU
（2）系统进程使用CPU的比率：系统在内核运行占用的时间
（3）iowait, CPU等待I/O 的比率：磁盘IO可能是瓶颈
（4）硬件中断占比，比如网卡读写
（5）CPU用于上下文交换的比率：是否进程/线程数过多
（6）平均负载,load 1/5/15 min：运行队列的平均长度，也就是等待CPU的平均进程数

查看上下文切换（Context switch）：vmstat
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   `cs` us sy id wa st
 0  0      0 1759500  49108  41724    0    0     1     0   13   10  0  0 100  0  0

查看中断情况：cat /proc/interrupts
           CPU0       
  0:        132    XT-PIC-XT        timer
  1:          8    XT-PIC-XT        i8042
  2:          0    XT-PIC-XT        cascade
  8:          1    XT-PIC-XT        rtc0
  9:      35837    XT-PIC-XT        acpi, virtio1, vboxguest
 10:       1246    XT-PIC-XT        virtio0
 11:     455436    XT-PIC-XT        ahci, virtio2
 12:        143    XT-PIC-XT        i8042
NMI:          0   Non-maskable interrupts
LOC:     679699   Local timer interrupts
SPU:          0   Spurious interrupts
PMI:          0   Performance monitoring interrupts
IWI:          0   IRQ work interrupts
RES:          0   Rescheduling interrupts
CAL:          0   Function call interrupts
TLB:          0   TLB shootdowns
TRM:          0   Thermal event interrupts
THR:          0   Threshold APIC interrupts
MCE:          0   Machine check exceptions
MCP:        296   Machine check polls
ERR:          0
MIS:          0

#### 4.mem usgage
![image](https://github.com/woojean/woojean.github.io/blob/master/images/test_4.png)
Total mem usage：
（1）Mem： 物理内存
（2）Swap：磁盘空间

查看当前内存使用情况：free
             total       used       free     shared    buffers     cached
Mem:       1922484     162984    1759500          0      49164      41744
-/+ buffers/cache:      72076    1850408
Swap:      1254392          0    1254392

系统实际内存占用以及可用内存有如下几个加减法：
used = total-free 即 total=used+free
实际内存占用：used-buffers-cached 即 total-free-buffers-cached
实际可用内存：buffers+cached+free

查看内存额定值：cat /proc/meminfo
MemTotal:        1922484 kB
MemFree:         1759500 kB
Buffers:           49204 kB
Cached:            41756 kB
SwapCached:            0 kB
Active:            54160 kB
Inactive:          50064 kB
Active(anon):      13276 kB
Inactive(anon):      144 kB
Active(file):      40884 kB
Inactive(file):    49920 kB
Unevictable:           0 kB
Mlocked:               0 kB
SwapTotal:       1254392 kB
SwapFree:        1254392 kB
Dirty:                 0 kB
Writeback:             0 kB
（略）

#### mem usage – 进程的角度
`
#cat /proc/[pid]/status
#cat /proc/`ps -ef|grep hello | grep -v grep | awk '{print $2}'`/status | grep -E ' VmSize|VmRSS|VmData|VmStk|VmExe|VmLib'
`
VmSize (KB) ：虚拟内存大小。整个进程使用虚拟内存大小，是VmLib, VmExe,VmData, 和VmStk的总和
VmRSS (KB)：虚拟内存驻留集合大小。这是驻留在物理内存的一部分。它没有交换到硬盘。它包括代码，数据和栈
VmData (KB)： 程序数据段的大小（所占虚拟内存的大小），堆使用的虚拟内存
VmStk (KB)： 任务在用户态的栈的大小，栈使用的虚拟内存
VmExe (KB)： 程序所拥有的可执行虚拟内存的大小，代码段，不包括任务使用的库
VmLib (KB) ：被映像到任务的虚拟内存空间的库的大小

### Windows下常见资源使用指标
perfmon
（略）

### 数据采集的进一步要求
获取一次指标只能反映某个时间点或者一小段时间的情况，如何持续的获取？如何展示？
可以连续的获取了，但是如何控制开始和结束的时间点？




## 7 测试结果的分析和报告

### 判断测试结果的有效性
1.工具给出的指标和我的理解一样？
2.工具给出的数据是否可靠？
3.数据有意义吗？

数据的意义，正确是前提：能同时支持xx并发用户，每秒处理yy个请求，平均响应时间是zz秒。
前提：
1.请求被正确的处理了（JMeter中可以使用断言）
2.工具的行为和用户的行为，或者我们期望的是一致的
3.是不是真正的并发？

### 测试指标的分析 
1.Page/s, Transaction/s, hit/s, Request/s
2.Self-defined transaction
3.产品层面的意义和技术层面的意义，如处理一项任务：
（1）涉及多少文件传输
（2）多少个连接
（3）多少个TCP包

### 关于响应时间 
常见的有下面几种：
1.事务的响应时间。这个响应时间通常是看整个事务处理完成的时间，比如提交一个订单到得到完整的响应。如上面所说，事务的定义就是不确实的，所以这个计时的起点和终点也随之而变。

2.页面响应时间。这个是针对WEB请求而言的，表示的是从发起请求到把整个页面的元素全部取回来的时间。

3.URL响应时间。通常一个页面包含不止一个元素，对应的URL也不止一个。URL响应时间表示的是从收到请求的ACK到完整取回一个URL的数据的时间。

4.服务器响应时间。这个是指服务器收到请求到开始返回请求的时间。其计算方法一是从服务器端来看，另外就是从客户端来看，从客户端来看的时候需要从发起请求到得到结果之间的时间中减去网络传输的时间。

5.连接时间。从TCP协议发出SYN到收到SYN,ACK的时间，其衡量的是来回的网络延迟。

6.第一个字节的时间（ TTFB,Time to First Byte ）。这个相比上面而言，是更细节的响应时间，简单的来说就是只从发出TCP请求到第一个数据包返回的时间，因为一个URL的数据可能包含多个数据包。如果网络状况比较差，或者服务器已经过载导致丢包较多，那么重传的时间也会被算在内，导致时间加长，所以这个响应时间对网络的延迟也比较敏感。

### 常见的统计方法
1.平均
2.最小/最大
3.Median，中值
4.90%
5.标准差

### 测试报告的注意事项
1.在summary中给出主要场景的测试结果
2.结论是什么
3.列出主要的测试场景、测试方法和工具、测试环境和测试样本等数据(类似测试计划)
4.相比summary中稍微细节的数据
5.测试中发现的问题


## 8 性能测试的辅助工具
（略）


## 9 性能测试的自动化
1.让不同用例的执行自动化
2.资源监控的自动化
3.让产品的安装和配置自动化


