# 基础原理知识点总结

## 计算机网络的层级划分及每层的工作内容
OSI的七层协议：应用层、表示层、会话层、运输层、网络层、数据链路层、物理层；
TCP/IP 是四层的体系结构：应用层、运输层、网际层和网络接口层。但最下面的网络接口层并没有具体内容。
因此往往采取折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构：
  应用层 ： FTP、TELNET、HTTP、SMTP、 POP3、DHCP、DNS
  运输层 ： TCP、UDP
  网络层 ： IP、ARP、ICMP、RIP、OSPF、路由器	# 虚拟互联网络
  数据链路层 ： PPP、CRC、FSC、CSMA/CD、交换机	# 封装成帧、 透明传输、差错控制
  物理层 ： ADSL、CDMA、集线器		# 物理信号传输（数、模）、信道复用（频分、时分、码分）



## TCP的Nagle算法
事实上，Nagle算法所谓的“提高网络利用率”只是它的一个副作用，`Nagle算法的主旨在于“避免发送‘大量’的小包”`。Nagle算法并没有阻止发送小包，它只是阻止了发送大量的小包！
TCP/IP协议中，无论发送多少数据，总是要在数据前面加上协议头，同时，对方接收到数据，也需要发送ACK表示确认。为了尽可能的利用网络带宽，TCP总是希望尽可能的发送足够大的数据。Nagle算法就是为了尽可能发送大块数据，避免网络中充斥着许多小数据块。
`Nagle算法的基本定义是任意时刻，最多只能有一个未被确认的小段`。 所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。Nagle的算法通常会在TCP程序里添加两行代码，在未确认数据发送的时候让发送器把数据送到缓存里。任何数据随后继续直到得到明显的数据确认或者直到攒到了一定数量的数据了再发包。
默认情况下，发送数据采用Nagle 算法。这样虽然提高了网络吞吐量，但是实时性却降低了，在一些交互性很强的应用程序来说是不允许的，使用TCP_NODELAY选项可以禁止Nagle 算法。

## Tcp连接的建立和断开的过程
TCP用三次握手建立连接：
1.A的TCP向B发出连接请求报文段，其首部中的`同步位SYN = 1`，并选择`序号seq = x`，表明传送数据时的第一个数据字节的序号是 x。
2.B的TCP收到连接请求报文段后，如同意，则发回确认。B 在确认报文段中应使`SYN = 1`，使`ACK = 1`，其确认号`ack = x+1`，自己选择的序号`seq = y`。
3.A收到此报文段后向B给出确认，其`ACK = 1`，确认号`ack = y+1`。A 的 TCP 通知上层应用进程，连接已经建立。B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立。 

TCP连接的断开：
1.数据传输结束后，通信的双方都可释放连接。现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的`FIN = 1`，其序号`seq = u`，等待 B 的确认。
2.B发出确认，确认号`ack = u+1`，而这个报文段自己的序号`seq = v`。TCP 服务器进程通知高层应用进程。从 A 到 B 这个方向的连接就释放了，TCP 连接处于`半关闭状态`。B 若发送数据，A 仍要接收。
3.若B已经没有要向 A 发送的数据，其应用进程就通知TCP释放连接。
4.A收到连接释放报文段后，必须发出确认。在确认报文段中`ACK = 1`，确认号`ack = w+1`，自己的序号`seq = u + 1`。

`注意`
### A必须等待2MSL的时间
第一，为了保证A发送的最后一个ACK报文段能够到达B。
第二，防止 “已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

### 双方同时启动关闭的情况
连接双方的应用进程同时发关闭命令，则双方TCP在发送完尚未处理的报文段后，发送FIN报文。各方TCP在FIN前所发报文都得到确认后，发 ACK确认它收到的FIN。各方在收到对方对FIN的确认后，同样等待一段时间再关闭连接。这称之为`同时关闭`（ simultaneous close ）。


## TCP的拥塞控制
`慢开始`：在主机刚刚开始发送报文段时可先将拥塞窗口 cwnd 设置为一个最大报文段 MSS 的数值。在每收到一个对新的报文段的确认后，将拥塞窗口增加至多一个 MSS 的数值。用这样的方法逐步增大发送端的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。 

`拥塞避免`：当拥塞窗口值大于慢开始门限时，停止使用慢开始算法而改用拥塞避免算法。拥塞避免算法使发送端的拥塞窗口每经过一个往返时延RTT就增加一个MSS的大小。

`快重传`算法规定，发送端只要一连收到三个重复的 ACK 即可断定有分组丢失了，就应立即重传丢失的报文段而不必继续等待为该报文段设置的重传计时器的超时。

`快恢复`算法：
(1) 当发送端收到连续三个重复的 ACK 时，就重新设置慢开始门限 ssthresh。
(2) 与慢开始不同之处是拥塞窗口 cwnd 不是设置为 1，而是设置为 ssthresh + 3 *MSS。 
(3) 若收到的重复的 ACK 为 n 个（n > 3），则将 cwnd 设置为 ssthresh + n * MSS。
(4) 若发送窗口值还容许发送报文段，就按拥塞避免算法继续发送报文段。
(5) 若收到了确认新的报文段的 ACK，就将 cwnd 缩小到 ssthresh。

`“乘法减小“`是指不论在慢开始阶段还是拥塞避免阶段，只要出现一次超时（即出现一次网络拥塞），就把慢开始门限值 ssthresh 设置为当前的拥塞窗口值乘以 0.5。当网络频繁出现拥塞时，ssthresh 值就下降得很快，以大大减少注入到网络中的分组数。

`“加法增大”`是指执行拥塞避免算法后，当收到对所有报文段的确认就将拥塞窗口 cwnd增加一个 MSS 大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。 

### 拥塞控制与流量控制的区别 
1.拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。
2.拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 
3.流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制。 
4.流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。
流量控制(flow control)就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。



## TCP可靠通信的实现原理
1.TCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。
2.TCP 的可靠传输机制用字节的序号进行控制。`TCP所有的确认都是基于序号`而不是基于报文段。
3.TCP 两端的四个窗口经常处于动态变化之中。
4.TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算较为合理的重传时间。


## 域名的解析过程
主机向本地域名服务器的查询一般都是采用递归查询。如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文。
本地域名服务器向根域名服务器的查询通常是采用迭代查询。当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询。

## TCP端口
端口用一个 16 位端口号进行标志。`端口号只具有本地意义`，即端口号只是为了标志本计算机应用层中的各进程。
三类端口:
1.`熟知端口`，数值一般为 0~1023。
2.`登记端口号`，数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。
3.`客户端口号或短暂端口号`，数值为49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。

## UDP的主要特点
UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即`端口的功能和差错检测的功能`。虽然 UDP 用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其特殊的优点。
1.UDP 是`无连接`的，即发送数据之前不需要建立连接。
2.UDP 使用`尽最大努力交付`，即不保证可靠交付，同时也不使用拥塞控制。
3.UDP 是`面向报文`的。UDP 没有拥塞控制，很适合多媒体通信的要求。 
4.UDP 支持`一对一、一对多、多对一和多对多`的交互通信。
5.UDP 的`首部开销小`，只有 8 个字节。

## TCP 最主要的特点
1.TCP 是`面向连接`的运输层协议。
2.每一条 TCP 连接`只能有两个端点`(endpoint)，每一条 TCP 连接只能是点对点的（一对一）。 
3.TCP 提供`可靠交付`的服务。
4.TCP 提供`全双工`通信。
5.面向字节流。

`注意`
1.TCP 连接是一条`虚连接`而不是一条真正的物理连接。
2.TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是不关心的。
3.TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。
4.TCP 可把太长的数据块划分短一些再传送。TCP 也可等待积累有足够多的字节后再构成报文段发送出去。

网络通信中，write返回成功后，是否确保数据发送成功或是被对端服务收到？
不是，只是表明待发送数据已被写入系统缓存；


## TCP滑动窗口
TCP 把连接作为最基本的抽象。每一条 TCP 连接有两个端点。TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做`套接字(socket)`或插口。端口号拼接到(contatenated with) IP 地址即构成了套接字。每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。

以字节为单位的滑动窗口,根据 B 给出的窗口值
1.A 构造出自己的发送窗口
2.A 发送了 11 个字节的数据
  P3 – P1 = A 的`发送窗口`（又称为通知窗口）
  P2 – P1 = 已发送但尚未收到确认的字节数
  P3 – P2 = 允许发送但尚未发送的字节数（又称为`可用窗口`） 

3.A 收到新的确认号，发送窗口向前滑动
4.A 的发送窗口内的序号都已用完，但还没有再收到确认，必须停止发送。


### TCP发送缓存与接收缓存
发送缓存用来暂时存放：
 1.发送应用程序传送给发送方 TCP 准备发送的数据；
 2.TCP 已发送出但尚未收到确认的数据。

接收缓存用来暂时存放：
 1.按序到达的、但尚未被接收应用程序读取的数据；
 2.不按序到达的数据。

`注意`：
1.A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。
2.TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。
3.TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。

## 划分子网与构造超网
划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号 net-id，先找到连接在本单位网络上的路由器。然后此路由器在收到 IP 数据报后，再按目的网络号 net-id 和子网号 subnet-id 找到目的子网。

`子网掩码`是一个网络或一个子网的重要属性。
路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。
路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。
若一个路由器连接在两个子网上就拥有两个网络地址和两个子网掩码。
不同的子网掩码可能得出相同的网络地址。但不同的掩码的效果是不同的。 

在划分子网的情况下路由器转发分组的算法 
(1) 从收到的分组的首部提取目的 IP 地址 D。
(2) 先用各网络的子网掩码和 D 逐位相“与”，看是否和相应的网络地址匹配。若匹配，则将分组直接交付。否则就是间接交付，执行(3)。
(3) 若路由表中有目的地址为 D 的特定主机路由，则将分组传送给指明的下一跳路由器；否则，执行(4)。
(4) 对路由表中的每一行的子网掩码和 D 逐位相“与”，若其结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行(5)。
(5) 若路由表中有一个默认路由，则将分组传送给路由表中所指明的默认路由器；否则，执行(6)。
(6) 报告转发分组出错。


























